{"ast":null,"code":"'use strict';\n\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = function (fn) {\n  let {\n    cacheKey,\n    cache = new Map(),\n    maxAge\n  } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  if (typeof maxAge === 'number') {\n    // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n    // @ts-expect-error\n    mapAgeCleaner(cache);\n  }\n  const memoized = function () {\n    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {\n      arguments_[_key] = arguments[_key];\n    }\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = cache.get(key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n    const result = fn.apply(this, arguments_);\n    cache.set(key, {\n      data: result,\n      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n    });\n    return result;\n  };\n  mimicFn(memoized, fn, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = function () {\n  let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== 'function') {\n      throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n      if (!decoratorInstanceMap.has(this)) {\n        const value = mem(input, options);\n        decoratorInstanceMap.set(this, value);\n        return value;\n      }\n      return decoratorInstanceMap.get(this);\n    };\n  };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = fn => {\n  const cache = cacheStore.get(fn);\n  if (!cache) {\n    throw new TypeError('Can\\'t clear a function that was not memoized!');\n  }\n  if (typeof cache.clear !== 'function') {\n    throw new TypeError('The cache Map can\\'t be cleared!');\n  }\n  cache.clear();\n};\nmodule.exports = mem;","map":{"version":3,"names":["mimicFn","require","mapAgeCleaner","decoratorInstanceMap","WeakMap","cacheStore","mem","fn","cacheKey","cache","Map","maxAge","arguments","length","undefined","memoized","_len","arguments_","Array","_key","key","cacheItem","get","data","result","apply","set","Date","now","Number","POSITIVE_INFINITY","ignoreNonConfigurable","decorator","options","target","propertyKey","descriptor","input","TypeError","value","writable","has","clear","module","exports"],"sources":["/Users/amircharkhi/Documents/amir/projects/ai-tech-institute/node_modules/mem/dist/index.js"],"sourcesContent":["'use strict';\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param fn - Function to be memoized.\n\n@example\n```\nimport mem = require('mem');\n\nlet i = 0;\nconst counter = () => ++i;\nconst memoized = mem(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same arguments\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nconst mem = (fn, { cacheKey, cache = new Map(), maxAge } = {}) => {\n    if (typeof maxAge === 'number') {\n        // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n        // @ts-expect-error\n        mapAgeCleaner(cache);\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = fn.apply(this, arguments_);\n        cache.set(key, {\n            data: result,\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n        });\n        return result;\n    };\n    mimicFn(memoized, fn, {\n        ignoreNonConfigurable: true\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n};\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport mem = require('mem');\n\nclass Example {\n    index = 0\n\n    @mem.decorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @mem.decorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n    const input = target[propertyKey];\n    if (typeof input !== 'function') {\n        throw new TypeError('The decorated value must be a function');\n    }\n    delete descriptor.value;\n    delete descriptor.writable;\n    descriptor.get = function () {\n        if (!decoratorInstanceMap.has(this)) {\n            const value = mem(input, options);\n            decoratorInstanceMap.set(this, value);\n            return value;\n        }\n        return decoratorInstanceMap.get(this);\n    };\n};\n/**\nClear all cached data of a memoized function.\n\n@param fn - Memoized function.\n*/\nmem.clear = (fn) => {\n    const cache = cacheStore.get(fn);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n};\nmodule.exports = mem;\n"],"mappings":"AAAA,YAAY;;AACZ,MAAMA,OAAO,GAAGC,OAAO,CAAC,UAAU,CAAC;AACnC,MAAMC,aAAa,GAAGD,OAAO,CAAC,iBAAiB,CAAC;AAChD,MAAME,oBAAoB,GAAG,IAAIC,OAAO,CAAC,CAAC;AAC1C,MAAMC,UAAU,GAAG,IAAID,OAAO,CAAC,CAAC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAME,GAAG,GAAG,SAAAA,CAACC,EAAE,EAAmD;EAAA,IAAjD;IAAEC,QAAQ;IAAEC,KAAK,GAAG,IAAIC,GAAG,CAAC,CAAC;IAAEC;EAAO,CAAC,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EACzD,IAAI,OAAOD,MAAM,KAAK,QAAQ,EAAE;IAC5B;IACA;IACAT,aAAa,CAACO,KAAK,CAAC;EACxB;EACA,MAAMM,QAAQ,GAAG,SAAAA,CAAA,EAAyB;IAAA,SAAAC,IAAA,GAAAJ,SAAA,CAAAC,MAAA,EAAZI,UAAU,OAAAC,KAAA,CAAAF,IAAA,GAAAG,IAAA,MAAAA,IAAA,GAAAH,IAAA,EAAAG,IAAA;MAAVF,UAAU,CAAAE,IAAA,IAAAP,SAAA,CAAAO,IAAA;IAAA;IACpC,MAAMC,GAAG,GAAGZ,QAAQ,GAAGA,QAAQ,CAACS,UAAU,CAAC,GAAGA,UAAU,CAAC,CAAC,CAAC;IAC3D,MAAMI,SAAS,GAAGZ,KAAK,CAACa,GAAG,CAACF,GAAG,CAAC;IAChC,IAAIC,SAAS,EAAE;MACX,OAAOA,SAAS,CAACE,IAAI;IACzB;IACA,MAAMC,MAAM,GAAGjB,EAAE,CAACkB,KAAK,CAAC,IAAI,EAAER,UAAU,CAAC;IACzCR,KAAK,CAACiB,GAAG,CAACN,GAAG,EAAE;MACXG,IAAI,EAAEC,MAAM;MACZb,MAAM,EAAEA,MAAM,GAAGgB,IAAI,CAACC,GAAG,CAAC,CAAC,GAAGjB,MAAM,GAAGkB,MAAM,CAACC;IAClD,CAAC,CAAC;IACF,OAAON,MAAM;EACjB,CAAC;EACDxB,OAAO,CAACe,QAAQ,EAAER,EAAE,EAAE;IAClBwB,qBAAqB,EAAE;EAC3B,CAAC,CAAC;EACF1B,UAAU,CAACqB,GAAG,CAACX,QAAQ,EAAEN,KAAK,CAAC;EAC/B,OAAOM,QAAQ;AACnB,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACAT,GAAG,CAAC0B,SAAS,GAAG;EAAA,IAACC,OAAO,GAAArB,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,CAAC,CAAC;EAAA,OAAK,CAACsB,MAAM,EAAEC,WAAW,EAAEC,UAAU,KAAK;IACnE,MAAMC,KAAK,GAAGH,MAAM,CAACC,WAAW,CAAC;IACjC,IAAI,OAAOE,KAAK,KAAK,UAAU,EAAE;MAC7B,MAAM,IAAIC,SAAS,CAAC,wCAAwC,CAAC;IACjE;IACA,OAAOF,UAAU,CAACG,KAAK;IACvB,OAAOH,UAAU,CAACI,QAAQ;IAC1BJ,UAAU,CAACd,GAAG,GAAG,YAAY;MACzB,IAAI,CAACnB,oBAAoB,CAACsC,GAAG,CAAC,IAAI,CAAC,EAAE;QACjC,MAAMF,KAAK,GAAGjC,GAAG,CAAC+B,KAAK,EAAEJ,OAAO,CAAC;QACjC9B,oBAAoB,CAACuB,GAAG,CAAC,IAAI,EAAEa,KAAK,CAAC;QACrC,OAAOA,KAAK;MAChB;MACA,OAAOpC,oBAAoB,CAACmB,GAAG,CAAC,IAAI,CAAC;IACzC,CAAC;EACL,CAAC;AAAA;AACD;AACA;AACA;AACA;AACA;AACAhB,GAAG,CAACoC,KAAK,GAAInC,EAAE,IAAK;EAChB,MAAME,KAAK,GAAGJ,UAAU,CAACiB,GAAG,CAACf,EAAE,CAAC;EAChC,IAAI,CAACE,KAAK,EAAE;IACR,MAAM,IAAI6B,SAAS,CAAC,gDAAgD,CAAC;EACzE;EACA,IAAI,OAAO7B,KAAK,CAACiC,KAAK,KAAK,UAAU,EAAE;IACnC,MAAM,IAAIJ,SAAS,CAAC,kCAAkC,CAAC;EAC3D;EACA7B,KAAK,CAACiC,KAAK,CAAC,CAAC;AACjB,CAAC;AACDC,MAAM,CAACC,OAAO,GAAGtC,GAAG","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}