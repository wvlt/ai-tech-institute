{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map) {\n  let property = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'maxAge';\n  let processingKey;\n  let processingTimer;\n  let processingDeferred;\n  const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n    if (processingKey !== undefined) {\n      // If we are already processing an item, we can safely exit\n      return;\n    }\n    const setupTimer = item => __awaiter(this, void 0, void 0, function* () {\n      processingDeferred = p_defer_1.default();\n      const delay = item[1][property] - Date.now();\n      if (delay <= 0) {\n        // Remove the item immediately if the delay is equal to or below 0\n        map.delete(item[0]);\n        processingDeferred.resolve();\n        return;\n      }\n      // Keep track of the current processed key\n      processingKey = item[0];\n      processingTimer = setTimeout(() => {\n        // Remove the item when the timeout fires\n        map.delete(item[0]);\n        if (processingDeferred) {\n          processingDeferred.resolve();\n        }\n      }, delay);\n      // tslint:disable-next-line:strict-type-predicates\n      if (typeof processingTimer.unref === 'function') {\n        // Don't hold up the process from exiting\n        processingTimer.unref();\n      }\n      return processingDeferred.promise;\n    });\n    try {\n      for (const entry of map) {\n        yield setupTimer(entry);\n      }\n    } catch (_a) {\n      // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n    }\n    processingKey = undefined;\n  });\n  const reset = () => {\n    processingKey = undefined;\n    if (processingTimer !== undefined) {\n      clearTimeout(processingTimer);\n      processingTimer = undefined;\n    }\n    if (processingDeferred !== undefined) {\n      // tslint:disable-line:early-exit\n      processingDeferred.reject(undefined);\n      processingDeferred = undefined;\n    }\n  };\n  const originalSet = map.set.bind(map);\n  map.set = (key, value) => {\n    if (map.has(key)) {\n      // If the key already exist, remove it so we can add it back at the end of the map.\n      map.delete(key);\n    }\n    // Call the original `map.set`\n    const result = originalSet(key, value);\n    // If we are already processing a key and the key added is the current processed key, stop processing it\n    if (processingKey && processingKey === key) {\n      reset();\n    }\n    // Always run the cleanup method in case it wasn't started yet\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return result;\n  };\n  cleanup(); // tslint:disable-line:no-floating-promises\n  return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;","map":{"version":3,"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__importDefault","mod","__esModule","Object","defineProperty","exports","p_defer_1","require","mapAgeCleaner","map","property","arguments","length","undefined","processingKey","processingTimer","processingDeferred","cleanup","setupTimer","item","default","delay","Date","now","delete","setTimeout","unref","promise","entry","_a","reset","clearTimeout","originalSet","set","bind","key","has","module"],"sources":["/Users/amircharkhi/Documents/amir/projects/ai-tech-institute/node_modules/map-age-cleaner/dist/index.js"],"sourcesContent":["\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst p_defer_1 = __importDefault(require(\"p-defer\"));\nfunction mapAgeCleaner(map, property = 'maxAge') {\n    let processingKey;\n    let processingTimer;\n    let processingDeferred;\n    const cleanup = () => __awaiter(this, void 0, void 0, function* () {\n        if (processingKey !== undefined) {\n            // If we are already processing an item, we can safely exit\n            return;\n        }\n        const setupTimer = (item) => __awaiter(this, void 0, void 0, function* () {\n            processingDeferred = p_defer_1.default();\n            const delay = item[1][property] - Date.now();\n            if (delay <= 0) {\n                // Remove the item immediately if the delay is equal to or below 0\n                map.delete(item[0]);\n                processingDeferred.resolve();\n                return;\n            }\n            // Keep track of the current processed key\n            processingKey = item[0];\n            processingTimer = setTimeout(() => {\n                // Remove the item when the timeout fires\n                map.delete(item[0]);\n                if (processingDeferred) {\n                    processingDeferred.resolve();\n                }\n            }, delay);\n            // tslint:disable-next-line:strict-type-predicates\n            if (typeof processingTimer.unref === 'function') {\n                // Don't hold up the process from exiting\n                processingTimer.unref();\n            }\n            return processingDeferred.promise;\n        });\n        try {\n            for (const entry of map) {\n                yield setupTimer(entry);\n            }\n        }\n        catch (_a) {\n            // Do nothing if an error occurs, this means the timer was cleaned up and we should stop processing\n        }\n        processingKey = undefined;\n    });\n    const reset = () => {\n        processingKey = undefined;\n        if (processingTimer !== undefined) {\n            clearTimeout(processingTimer);\n            processingTimer = undefined;\n        }\n        if (processingDeferred !== undefined) { // tslint:disable-line:early-exit\n            processingDeferred.reject(undefined);\n            processingDeferred = undefined;\n        }\n    };\n    const originalSet = map.set.bind(map);\n    map.set = (key, value) => {\n        if (map.has(key)) {\n            // If the key already exist, remove it so we can add it back at the end of the map.\n            map.delete(key);\n        }\n        // Call the original `map.set`\n        const result = originalSet(key, value);\n        // If we are already processing a key and the key added is the current processed key, stop processing it\n        if (processingKey && processingKey === key) {\n            reset();\n        }\n        // Always run the cleanup method in case it wasn't started yet\n        cleanup(); // tslint:disable-line:no-floating-promises\n        return result;\n    };\n    cleanup(); // tslint:disable-line:no-floating-promises\n    return map;\n}\nexports.default = mapAgeCleaner;\n// Add support for CJS\nmodule.exports = mapAgeCleaner;\nmodule.exports.default = mapAgeCleaner;\n"],"mappings":"AAAA,YAAY;;AACZ,IAAIA,SAAS,GAAI,IAAI,IAAI,IAAI,CAACA,SAAS,IAAK,UAAUC,OAAO,EAAEC,UAAU,EAAEC,CAAC,EAAEC,SAAS,EAAE;EACrF,OAAO,KAAKD,CAAC,KAAKA,CAAC,GAAGE,OAAO,CAAC,EAAE,UAAUC,OAAO,EAAEC,MAAM,EAAE;IACvD,SAASC,SAASA,CAACC,KAAK,EAAE;MAAE,IAAI;QAAEC,IAAI,CAACN,SAAS,CAACO,IAAI,CAACF,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOG,CAAC,EAAE;QAAEL,MAAM,CAACK,CAAC,CAAC;MAAE;IAAE;IAC1F,SAASC,QAAQA,CAACJ,KAAK,EAAE;MAAE,IAAI;QAAEC,IAAI,CAACN,SAAS,CAAC,OAAO,CAAC,CAACK,KAAK,CAAC,CAAC;MAAE,CAAC,CAAC,OAAOG,CAAC,EAAE;QAAEL,MAAM,CAACK,CAAC,CAAC;MAAE;IAAE;IAC7F,SAASF,IAAIA,CAACI,MAAM,EAAE;MAAEA,MAAM,CAACC,IAAI,GAAGT,OAAO,CAACQ,MAAM,CAACL,KAAK,CAAC,GAAG,IAAIN,CAAC,CAAC,UAAUG,OAAO,EAAE;QAAEA,OAAO,CAACQ,MAAM,CAACL,KAAK,CAAC;MAAE,CAAC,CAAC,CAACO,IAAI,CAACR,SAAS,EAAEK,QAAQ,CAAC;IAAE;IAC9IH,IAAI,CAAC,CAACN,SAAS,GAAGA,SAAS,CAACa,KAAK,CAAChB,OAAO,EAAEC,UAAU,IAAI,EAAE,CAAC,EAAES,IAAI,CAAC,CAAC,CAAC;EACzE,CAAC,CAAC;AACN,CAAC;AACD,IAAIO,eAAe,GAAI,IAAI,IAAI,IAAI,CAACA,eAAe,IAAK,UAAUC,GAAG,EAAE;EACnE,OAAQA,GAAG,IAAIA,GAAG,CAACC,UAAU,GAAID,GAAG,GAAG;IAAE,SAAS,EAAEA;EAAI,CAAC;AAC7D,CAAC;AACDE,MAAM,CAACC,cAAc,CAACC,OAAO,EAAE,YAAY,EAAE;EAAEd,KAAK,EAAE;AAAK,CAAC,CAAC;AAC7D,MAAMe,SAAS,GAAGN,eAAe,CAACO,OAAO,CAAC,SAAS,CAAC,CAAC;AACrD,SAASC,aAAaA,CAACC,GAAG,EAAuB;EAAA,IAArBC,QAAQ,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAAG,QAAQ;EAC3C,IAAIG,aAAa;EACjB,IAAIC,eAAe;EACnB,IAAIC,kBAAkB;EACtB,MAAMC,OAAO,GAAGA,CAAA,KAAMnC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;IAC/D,IAAIgC,aAAa,KAAKD,SAAS,EAAE;MAC7B;MACA;IACJ;IACA,MAAMK,UAAU,GAAIC,IAAI,IAAKrC,SAAS,CAAC,IAAI,EAAE,KAAK,CAAC,EAAE,KAAK,CAAC,EAAE,aAAa;MACtEkC,kBAAkB,GAAGV,SAAS,CAACc,OAAO,CAAC,CAAC;MACxC,MAAMC,KAAK,GAAGF,IAAI,CAAC,CAAC,CAAC,CAACT,QAAQ,CAAC,GAAGY,IAAI,CAACC,GAAG,CAAC,CAAC;MAC5C,IAAIF,KAAK,IAAI,CAAC,EAAE;QACZ;QACAZ,GAAG,CAACe,MAAM,CAACL,IAAI,CAAC,CAAC,CAAC,CAAC;QACnBH,kBAAkB,CAAC5B,OAAO,CAAC,CAAC;QAC5B;MACJ;MACA;MACA0B,aAAa,GAAGK,IAAI,CAAC,CAAC,CAAC;MACvBJ,eAAe,GAAGU,UAAU,CAAC,MAAM;QAC/B;QACAhB,GAAG,CAACe,MAAM,CAACL,IAAI,CAAC,CAAC,CAAC,CAAC;QACnB,IAAIH,kBAAkB,EAAE;UACpBA,kBAAkB,CAAC5B,OAAO,CAAC,CAAC;QAChC;MACJ,CAAC,EAAEiC,KAAK,CAAC;MACT;MACA,IAAI,OAAON,eAAe,CAACW,KAAK,KAAK,UAAU,EAAE;QAC7C;QACAX,eAAe,CAACW,KAAK,CAAC,CAAC;MAC3B;MACA,OAAOV,kBAAkB,CAACW,OAAO;IACrC,CAAC,CAAC;IACF,IAAI;MACA,KAAK,MAAMC,KAAK,IAAInB,GAAG,EAAE;QACrB,MAAMS,UAAU,CAACU,KAAK,CAAC;MAC3B;IACJ,CAAC,CACD,OAAOC,EAAE,EAAE;MACP;IAAA;IAEJf,aAAa,GAAGD,SAAS;EAC7B,CAAC,CAAC;EACF,MAAMiB,KAAK,GAAGA,CAAA,KAAM;IAChBhB,aAAa,GAAGD,SAAS;IACzB,IAAIE,eAAe,KAAKF,SAAS,EAAE;MAC/BkB,YAAY,CAAChB,eAAe,CAAC;MAC7BA,eAAe,GAAGF,SAAS;IAC/B;IACA,IAAIG,kBAAkB,KAAKH,SAAS,EAAE;MAAE;MACpCG,kBAAkB,CAAC3B,MAAM,CAACwB,SAAS,CAAC;MACpCG,kBAAkB,GAAGH,SAAS;IAClC;EACJ,CAAC;EACD,MAAMmB,WAAW,GAAGvB,GAAG,CAACwB,GAAG,CAACC,IAAI,CAACzB,GAAG,CAAC;EACrCA,GAAG,CAACwB,GAAG,GAAG,CAACE,GAAG,EAAE5C,KAAK,KAAK;IACtB,IAAIkB,GAAG,CAAC2B,GAAG,CAACD,GAAG,CAAC,EAAE;MACd;MACA1B,GAAG,CAACe,MAAM,CAACW,GAAG,CAAC;IACnB;IACA;IACA,MAAMvC,MAAM,GAAGoC,WAAW,CAACG,GAAG,EAAE5C,KAAK,CAAC;IACtC;IACA,IAAIuB,aAAa,IAAIA,aAAa,KAAKqB,GAAG,EAAE;MACxCL,KAAK,CAAC,CAAC;IACX;IACA;IACAb,OAAO,CAAC,CAAC,CAAC,CAAC;IACX,OAAOrB,MAAM;EACjB,CAAC;EACDqB,OAAO,CAAC,CAAC,CAAC,CAAC;EACX,OAAOR,GAAG;AACd;AACAJ,OAAO,CAACe,OAAO,GAAGZ,aAAa;AAC/B;AACA6B,MAAM,CAAChC,OAAO,GAAGG,aAAa;AAC9B6B,MAAM,CAAChC,OAAO,CAACe,OAAO,GAAGZ,aAAa","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}